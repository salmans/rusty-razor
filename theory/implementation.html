<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Implementation - rusty-razor</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li><a href="model-finding.html"><strong aria-hidden="true">1.1.</strong> Conventional Model-Finding</a></li><li><a href="razor.html"><strong aria-hidden="true">1.2.</strong> Razor: A First-Order Approach</a></li></ol></li><li><a href="theory.html"><strong aria-hidden="true">2.</strong> Theory and Implementation</a></li><li><ol class="section"><li><a href="theory/chase.html"><strong aria-hidden="true">2.1.</strong> The Chase</a></li><li><a href="theory/implementation.html" class="active"><strong aria-hidden="true">2.2.</strong> Implementation</a></li></ol></li><li><a href="syntax.html"><strong aria-hidden="true">3.</strong> Syntax</a></li><li><ol class="section"><li><a href="syntax/variations.html"><strong aria-hidden="true">3.1.</strong> Syntactic Variations</a></li><li><a href="syntax/precedence.html"><strong aria-hidden="true">3.2.</strong> Connective Precedence</a></li><li><a href="syntax/grammar.html"><strong aria-hidden="true">3.3.</strong> Grammar</a></li></ol></li><li><a href="build.html"><strong aria-hidden="true">4.</strong> Build</a></li><li><a href="run.html"><strong aria-hidden="true">5.</strong> Run</a></li><li><ol class="section"><li><a href="run/bounded.html"><strong aria-hidden="true">5.1.</strong> Bounded Model-Finding</a></li><li><a href="run/scheduler.html"><strong aria-hidden="true">5.2.</strong> Model-Finding Scheduler</a></li></ol></li><li><a href="example.html"><strong aria-hidden="true">6.</strong> Example</a></li><li><ol class="section"><li><a href="example/valar-morghulis.html"><strong aria-hidden="true">6.1.</strong> Valar Morghulis</a></li><li><a href="example/golden-head.html"><strong aria-hidden="true">6.2.</strong> Golden Head</a></li><li><a href="example/hold-the-door.html"><strong aria-hidden="true">6.3.</strong> Hold the Door</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">rusty-razor</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="theory/implementation.html#implementation" id="implementation"><h2>Implementation</h2></a>
<p>Razor's model-finding algorithm is a variant of <a href="./theory/chase.html">the chase</a>, an
algorithm for constructing models for geometric theories. Given an
input first-order theory ùì£, Razor applies a standard syntactic
transformation to convert ùì£ to a <em>Geometric Normal Form</em> (GNF). The
result of this transformation is a geometric theory ùìñ that is
equisatisfiable with ùì£.</p>
<blockquote>
<p><strong>Note:</strong> Transformation to GNF consists of transforming the input
theory to a <a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form#Converting_from_first-order_logic">Conjunctive Normal Form</a> (CNF) followed by
rearranging the conjuncts of the resulting CNF into an implication,
where negative and positive conjuncts form the implication's premise
and consequence respectively. The implication is semantically
equivalent to a geometric sequence and is treated as such.</p>
<p>It's noteworthy that conversion to CNF involves
<a href="https://en.wikipedia.org/wiki/Skolem_normal_form"><em>Skolemization</em></a>, a transformation by which existential
quantifiers of the input theory are replaced with fresh &quot;Skolem
functions&quot;. Therefore, the resulting GNF is a theory over an extension
of the original vocabulary over which the input theory is defined.</p>
</blockquote>
<p>Let ùìñ be an input geometric theory. The essense of a
<a href="./theory/chase.html#step">chase-step</a> on a model ùïû is to find a sequent ùúë ‚ä¢<sub>ùòÖ</sub> ùúì
of ùìñ with an assignment from the variables in ùòÖ to the domain of ùïû
such that ùúë is true and ùúì is false in ùïû. A naive implementation of the
chase would iterate over all sequents of ùìñ and examine every
assignment from ùòÖ to the domain of ùïû. This would lead to |ùòÖ|<sup>|ùïû|</sup> valuations of ùúë and ùúì in ùïû where |ùòÖ| and |ùïû|
denote the size of ùòÖ and the domain size of ùïû respectively. Such a
naive implementation is extremely inefficient for practical
model-finding use-cases.</p>
<p>A practical implementation of the chase must address a number of
algorithmic challenges: it must provide efficient data-structures for
querying models and keeping track of various search branches; it
should implement effective heuristics for choosing a search branch and
for selecting a sequent to evaluate; and most importantly, it must
implement a fast solution for finding assignments from the free
variables in ùòÖ to the elements of ùïû.</p>
<a class="header" href="theory/implementation.html#a-namecodd-hello-codd" id="a-namecodd-hello-codd"><h3><a name="codd"/> Hello Codd!</h3></a>
<p><a href="https://en.wikipedia.org/wiki/Codd%27s_theorem">Codd's theorem</a> is a well known result from database theory
that establishes equivalence between <a href="https://en.wikipedia.org/wiki/Relational_algebra">relational algebra</a> and
<a href="https://en.wikipedia.org/wiki/Relational_calculus">relational calculus</a> thus first-order logic.  Razor takes
advantage of this equivalence to implement the chase efficiently with
the help of database theory. From a database perspective, a model ùïû
constructed by the chase can be thought of as a monotonically growing
database with relational tables for each predicate of the input theory
ùìñ. Consequently, positive existential formulae are expressed queries
with conjunction (‚àß), disjunction (‚à®), and existential quantifier (‚àÉ)
acting as relational join (‚ãà), set union (‚à™), and projection (‚àè).
Finally, a geometric sequent ùúë ‚ä¢<sub>ùòÖ</sub> ùúì is evaluated by a query
ùõ∑ - ùõπ, the set difference of the relational expressions corresponding
to ùúë and ùúì. Intuitively, evaluating ùõ∑ - ùõπ in ùïû results in a set of
tuples that assign values to the variables in ùòÖ such that ùúë is true
and ùúì is false, as required by the chase-step. After evaluating ùõ∑ -
ùõπ, the chase-step proceeds by inserting the resulting tuples in the
relations mentioned by ùõπ, thus, making ùúì true in ùïû.</p>
<p>Razor's implementation of the chase uses <a href="https://github.com/salmans/codd"><code>codd</code></a>, a minimal
in-memory database with relational expressions as queries. The
underlying database abstraction would enable Razor to take advantage
of many advances in database theory and particularly streaming
databases to run more efficiently.  For example, <code>codd</code> supports
incrementally updated materialized views that are used to avoid full
re-evaluation of expressions during a run of the chase as the
database (i.e., the model ùïû) grows.</p>
<a class="header" href="theory/implementation.html#relationalization" id="relationalization"><h4>Relationalization</h4></a>
<p>The algorithm based on relational algebra requires a relationalization
step to transform a given first-order theory ùì£ with function symbols
to an equivalent theory ùì£‚Ä≤ without functions.  Relationalization is a
standard transformation that involves flattening of complex terms
followed by replacing function symbols and constants (i.e., nullary
functions) with new predicates. This transformation also extends the
original theory with integrity axioms that preserve the semantics of
the eliminated functions.</p>
<p>A discussion about the details of relationalization is out of the
scope of this document. Here, I use an example to explain the core
idea. Consider the atomic formula below, where ùöÅ is a predicate, ùöè and
ùöê are function symbols, ùö° and ùö¢ are variables, and ùó∞ is a constant:</p>
<p>ùöÅ(ùöè(ùöê(ùö°), ùö¢), ùó∞)</p>
<p>To flatten this formula, we introduce fresh variables, namely
ùöü<sub>1</sub>, ùöü<sub>2</sub>, and ùöü<sub>3</sub> to recursively replace
complex terms, consisting of function applications and
constants. Notice that the original and the flattened formulae are
semantically equivalent:</p>
<p>ùöÅ(ùöü<sub>1</sub>, ùöü<sub>2</sub>) ‚àß ùöè(ùöü<sub>3</sub>, ùö¢) = ùöü<sub>1</sub>
‚àß ùöê(ùö°) = ùöü<sub>3</sub> ‚àß ùó∞ = ùöü<sub>2</sub></p>
<p>Next, for each function symbol of arity ùöó, we introduce a predicate of
arity ùöó + 1 and replace the equalities between function applications
and variables with atomic formulae over the new predicates:</p>
<p>ùöÅ(ùöü<sub>1</sub>, ùöü<sub>2</sub>) ‚àß ùôµ(ùöü<sub>3</sub>, ùö¢, ùöü<sub>1</sub>) ‚àß
ùô∂(ùö°, ùöü<sub>3</sub>) ‚àß ùô≤(ùöü<sub>2</sub>)</p>
<p>In the previous example, ùôµ, ùô∂, and ùô≤ replace ùöè, ùöê, and ùó∞ in that
order.  The last position of these predicates correspond to the output
of the functions that they replace. Finally, to preserve the semantics
of the eliminated functions, the following sequents are added to the
resulting theory ùì£‚Ä≤:</p>
<p>ùôµ(ùö°<sub>1</sub>, ùö°<sub>2</sub>, ùö¢) ‚àß ùôµ(ùö°‚Ä≤<sub>1</sub>, ùö°‚Ä≤<sub>2</sub>,
ùö¢‚Ä≤) ‚àß
ùö°<sub>1</sub> = ùö°‚Ä≤<sub>1</sub> ‚àß ùö°<sub>2</sub> = ùö°‚Ä≤<sub>2</sub> ‚ä¢ ùö¢ = ùö¢‚Ä≤<br />
ùô∂(ùö°, ùö¢) ‚àß ùô∂(ùö°‚Ä≤, ùö¢‚Ä≤) ‚àß ùö° = ùö°‚Ä≤ ‚ä¢ ùö¢ = ùö¢‚Ä≤<br />
ùô≤(ùö¢) ‚àß ùô≤(ùö¢‚Ä≤) ‚ä¢ ùö¢ = ùö¢‚Ä≤</p>
<p>These sequents ensure that the new predicates are interpreted by
relations that map every vector of input arguments to exactly one
output, as the original functions do.</p>
<blockquote>
<p><strong>Note:</strong> It's common to add another set of sequents to the
resulting relationalized theory to preserve the totality of
functions. The chase, however, interprets the functions of the input
theory as partial functions; therefore, we're not concerned with
preserving totality.</p>
</blockquote>
<a class="header" href="theory/implementation.html#a-nameequality-equality" id="a-nameequality-equality"><h4><a name=equality/> Equality</h4></a>
<p>Interpreting equality as a relation can be done by axiomatizing
equality as a predicate, captured by the following sequents with = as
a special binary predicate symbol:</p>
<pre> 
‚ä§ ‚ä¢ =(x, x)                (reflexivity) 
=(ùö°, ùö¢) ‚ä¢ =(ùö¢, ùö°)           (symmetry) 
=(ùö°, ùö¢) ‚àß =(ùö¢, ùö£) ‚ä¢ =(ùö°, ùö£) (transitivity) 
</pre>
<blockquote>
<p><strong>Note:</strong> Our treatment of equality takes advantage of the fact that
equality axioms can be expressed as geometric sequents.</p>
</blockquote>
<a class="header" href="theory/implementation.html#variable-linearization" id="variable-linearization"><h4>Variable Linearization</h4></a>
<p>The translation to relational algebra must account for a number of
practical challenges regarding variables and their order of appearance
in formulae. From a database perspective, each position on the
first-order predicates represents a relational <em>attribute</em> (i.e., a
column of a relational table).  Therefore, the variables of the
formulae in the input theory enforce equality constraints on the
resulting select query. Specifically, the positions of two conjoined
predicates that are occupied by the same variable specify the <em>key
attributes</em> of a relatoinal join where equality between join
attributes is defined by the relation = from the <a href="theory/implementation.html#equality">previous
section</a>. As a result, Razor applies a standard
<em>linearization</em> transformation that assigns unique names to variables
that occupy positions on any predicate except for =. When renaming
variables, linearization introduces additional equalities between the
freshly introduced unique variables that rename the same variable in
the input formula.</p>
<p>Now, I will use another example to describe linearization:</p>
<p>ùôø(ùö°) ‚àß ùöÄ(ùö¢, ùö°, ùö¢)</p>
<p>A possible linearized version of the formula above is obtained by
renaming the second occurances of x and ùö¢, in ùöÄ(ùö¢, ùö°, ùö¢), with new
variables, namely x<sub>0</sub> and ùö¢<sub>0</sub>. In addition, =(x,
x<sub>0</sub>) and =(ùö¢, ùö¢<sub>0</sub>) are conjoined into the formula
to preserve equality between a variable and its renaming counterpart:</p>
<p>ùôø(ùö°) ‚àß ùöÄ(ùö¢, ùö°<sub>0</sub>, ùö¢<sub>0</sub>) ‚àß =(x, x<sub>0</sub>) ‚àß =(ùö¢,
ùö¢<sub>0</sub>)</p>
<a class="header" href="theory/implementation.html#range-restriction" id="range-restriction"><h4>Range Restriction</h4></a>
<p>I mentioned <a href="theory/implementation.html#codd">earlier</a> that in our implementation of the chase
based on relational algebra, a sequent ùúë ‚ä¢<sub>ùòÖ</sub> ùúì is evaluated
as a relational expression ùõ∑ - ùõπ where ùõ∑ and ùõπ are relational
expression obtained by transforming ùúë and ùúì. The set difference
operator is defined only when the attributes of ùõ∑ and ùõπ align; that
is, they must share the same attributes in the same order. If ùõ∑ and ùõπ
share the same set of attributes but in different orders, it's always
possible to project either of the expressions to match the order of
attributes. If ùõ∑ and ùõπ have different attributes, two cases are
possible:</p>
<ol>
<li>An attribute ùú∂ appears in ùõ∑ but not in ùõπ. In this case, we simply
project ùú∂ out of ùõ∑.</li>
<li>An attribute ùú∑ appears in ùõπ but not in ùõ∑. The treatment for this
case involves <em>range restriction</em> as described below.</li>
</ol>
<p>In database theory, a range-restricted query</p>
<blockquote>
<p>talk about other implementations</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="theory/chase.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="theory/chase.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
