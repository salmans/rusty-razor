use razor_fol::syntax;

// The naming prefix of existential attributes and variables in relational formulae.
pub(super) const EXISTENTIAL_PREFIX: &str = "?";

// The naming prefix of equational attributes and variables in relational formulae.
pub(super) const EQUATIONAL_PREFIX: &str = "~";

// The naming prefix of constant predicates created by relationalization
pub(super) const CONSTANT_PREDICATE_PREFIX: &str = "@";

// The naming prefix of functional predicates created by relationalization
pub(super) const FUNCTIONAL_PREDICATE_PREFIX: &str = "$";

// Seperates the different parts of attribute and variable names.
pub(super) const SEPERATOR: &str = ":";

// Is the name of the database instance that stores the domain of elements.
pub(super) const DOMAIN: &str = "$$domain";

// Is the name of the database instance for the equality relation.
pub(super) const EQUALITY: &str = razor_fol::syntax::EQ_SYM;

// Is the prefix associated to constants generated by Skolemization.
pub(super) const SKOLEM_CONST_PREFIX: &str = "c#";

// Is the prefix associated to functions generated by Skolemization.
pub(super) const SKOLEM_FN_PREFIX: &str = "f#";

// Creates the database instance name for the given constant.
#[inline]
pub(super) fn constant_instance_name(c: &syntax::Const) -> String {
    format!("@{}", c.name())
}

// Creates the database instance name for the given function symbol.
#[inline]
pub(super) fn function_instance_name(f: &syntax::Func) -> String {
    format!("${}", f.name())
}

// Creates the database instance name for the given predicate.
#[inline]
pub(super) fn predicate_instance_name(p: &syntax::Pred) -> String {
    p.to_string()
}

// Creates names for constants introduced by Skolemization.
#[inline]
pub(super) fn skolem_constant_name(index: u32) -> String {
    format!("{}{}", SKOLEM_CONST_PREFIX, index)
}

// Creates names for functions introduced by Skolemization.
#[inline]
pub(super) fn skolem_function_name(index: u32) -> String {
    format!("{}{}", SKOLEM_FN_PREFIX, index)
}

// Creates names for existential variables.
#[inline]
pub(super) fn existential_variable_name(index: u32) -> String {
    format!("{}{}", EXISTENTIAL_PREFIX, index)
}

// Creates names for existential variables used for linearization.
#[inline]
pub(super) fn linear_variable_name(name: &str, index: u32) -> String {
    format!("{}{}{}{}", EQUATIONAL_PREFIX, name, SEPERATOR, index).into()
}

// Returns true if a flat (variable) term corresponds to an existential quantifier or the
// result of a function application.
pub(super) fn is_existential_variable(name: &str) -> bool {
    name.starts_with(EXISTENTIAL_PREFIX)
}

// Returns true if the relational predicate corresponds to a function (or a constant)
pub(super) fn is_function_predicate(name: &str) -> bool {
    name.starts_with(CONSTANT_PREDICATE_PREFIX) || name.starts_with(FUNCTIONAL_PREDICATE_PREFIX)
}

// Returns true if the relational predicate corresponds to a function (or a constant)
pub(super) fn is_skolem_predicate(name: &str) -> bool {
    assert!(!name.is_empty());
    let postfix = &name[1..];
    is_function_predicate(name)
        && (postfix.starts_with(SKOLEM_CONST_PREFIX) || postfix.starts_with(SKOLEM_FN_PREFIX))
}
