/*! Implements conversion to Skolem Normal Form (SNF) for formula.*/

use super::TermBased;
use crate::syntax::{Formula::*, *};
use std::collections::HashMap;

/// Generates Skolem names in an incremental fashion in the context of any transformation that
/// involves Skolemization.
///
/// **Note**: To ensure all Skolem functions in a theory are unique, the same instance of
/// `SkolemGenerator` must be used when transforming all formulae of the theory.
#[derive(PartialEq, Debug)]
pub struct SkolemGenerator {
    /// Is a prefix for the names generated by the generator.
    prefix: String,
    /// Is the next index to be appended to `prefix`.
    index: i32,
}

impl SkolemGenerator {
    /// Creates a new `SkolemGenerator` with the default prefix `"sk#"`.
    pub fn new() -> Self {
        Self {
            prefix: "sk#".to_owned(),
            index: 0,
        }
    }

    /// Returns the next Skolem name.
    pub fn next(&mut self) -> String {
        let result = format!("{}{}", self.prefix, self.index);
        self.index += 1;
        result
    }
}

impl From<&str> for SkolemGenerator {
    /// Creates a `SkolemGenerator` instance with the given prefix.
    fn from(prefix: &str) -> Self {
        Self {
            prefix: prefix.to_owned(),
            index: 0,
        }
    }
}

fn helper(formula: Formula, mut skolem_vars: Vec<V>, generator: &mut SkolemGenerator) -> Formula {
    match formula {
        Forall { variables, formula } => {
            skolem_vars.append(&mut variables.clone());
            forall(variables, helper(*formula, skolem_vars, generator))
        }
        Exists { variables, formula } => {
            let mut map: HashMap<&V, Term> = HashMap::new();

            variables.iter().for_each(|v| {
                if skolem_vars.is_empty() {
                    map.insert(&v, C::from(&generator.next()).into());
                } else {
                    let vars: Vec<Term> = skolem_vars.iter().map(|v| v.clone().into()).collect();
                    map.insert(&v, F::from(&generator.next()).app(vars));
                }
            });

            let substituted = formula.substitute(&map);
            helper(substituted, skolem_vars, generator)
        }
        _ => formula,
    }
}

impl Formula {
    /// Returns a Skolem Normal Form (SNF) equivalent to the receiver.
    ///
    /// **Hint**: An SNF is a [PNF] with only universal quantifiers
    /// (see: <https://en.wikipedia.org/wiki/Skolem_normal_form>).
    ///
    /// [PNF]: ./enum.Formula.html#method.pnf
    ///
    /// **Example**:
    /// ```rust
    /// # use razor_fol::syntax::Formula;
    ///
    /// let formula: Formula = "∃ y. P(x, y)".parse().unwrap();
    /// assert_eq!("P(x, sk#0(x))", formula.snf().to_string());
    /// ```
    pub fn snf(&self) -> Formula {
        self.snf_with(&mut SkolemGenerator::new())
    }

    /// Is similar to [`Formula::snf`] but uses an existing [`SkolemGenerator`] to avoid collision
    /// when generating Skolem function names (including Skolem constants).
    ///
    ///
    /// [`Formula::snf`]: ./enum.Formula.html#method.snf
    /// [`SkolemGenerator`]: ../transform/struct.SkolemGenerator.html
    ///
    /// **Example**:
    /// ```rust
    /// # use razor_fol::syntax::Formula;
    /// use razor_fol::transform::SkolemGenerator;
    ///
    /// let mut generator = SkolemGenerator::from("skolem");
    /// let formula: Formula = "∃ y. P(x, y)".parse().unwrap();
    /// assert_eq!("P(x, skolem0(x))", formula.snf_with(&mut generator).to_string());
    /// ```
    pub fn snf_with(&self, generator: &mut SkolemGenerator) -> Formula {
        // Skolemization only makes sense for PNF formulae.
        let free_vars: Vec<V> = self.free_vars().into_iter().map(|v| v.clone()).collect();
        helper(self.pnf(), free_vars, generator)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{assert_debug_string, formula};

    #[test]
    fn test_skolem_generator() {
        assert_eq!(
            SkolemGenerator {
                prefix: "sk#".to_owned(),
                index: 0
            },
            SkolemGenerator::new()
        );
        {
            let mut gen = SkolemGenerator::new();
            assert_eq!("sk#0", gen.next());
            assert_eq!("sk#1", gen.next());
            assert_eq!("sk#2", gen.next());
        }
        {
            let mut gen = SkolemGenerator::from("razor");
            assert_eq!("razor0", gen.next());
            assert_eq!("razor1", gen.next());
            assert_eq!("razor2", gen.next());
        }
    }

    #[test]
    fn test_snf() {
        assert_debug_string!("P('sk#0)", formula!(? x. (P(x))).snf());

        assert_debug_string!("! x. P(x, sk#0(x))", formula!(!x. (?y. (P(x, y)))).snf());
        assert_debug_string!("P(x, sk#0(x))", formula!(?y. (P(x, y))).snf());
        assert_debug_string!(
            "! x. P(x, f(g(sk#0(x)), h(sk#0(x))))",
            formula!(!x. (? y. (P(x, f(g(y), h(y)))))).snf(),
        );
        assert_debug_string!(
            "('sk#0 = 'sk#1) & ('sk#1 = 'sk#2)",
            formula!(? x, y, z. (((x) = (y)) & ((y) = (z)))).snf(),
        );
        assert_debug_string!(
            "! y. (Q('sk#0, y) | P(sk#1(y), y, sk#2(y)))",
            formula!(? x. (! y. ((Q(x, y)) | (? x, z. (P(x, y, z)))))).snf(),
        );
        assert_debug_string!(
            "! x. (! z. P(x, sk#0(x), z))",
            formula!(! x. (? y.( ! z. (P(x, y, z))))).snf(),
        );
        assert_debug_string!(
            "! x. (R(g(x)) | R(x, sk#0(x)))",
            formula!(! x. ((R(g(x))) | (? y. (R(x, y))))).snf(),
        );
        assert_debug_string!(
            "! y. (! z. (! v. P('sk#0, y, z, sk#1(y, z), v, sk#2(y, z, v))))",
            formula!(? x. (! y. (! z. (? u. (! v. (? w. (P(x, y, z, u, v, w)))))))).snf(),
        );
        {
            let mut generator = SkolemGenerator::new();
            assert_debug_string!("P('sk#0)", formula!(? x. (P(x))).snf_with(&mut generator));
            assert_debug_string!("Q('sk#1)", formula!(? x. (Q(x))).snf_with(&mut generator));
        }
    }
}
