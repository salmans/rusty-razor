<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rusty-razor</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li><a href="model-finding.html"><strong aria-hidden="true">1.1.</strong> Conventional Model-Finding</a></li><li><a href="razor.html"><strong aria-hidden="true">1.2.</strong> Razor: A First-Order Approach</a></li></ol></li><li><a href="theory.html"><strong aria-hidden="true">2.</strong> Theory and Implementation</a></li><li><ol class="section"><li><a href="theory/chase.html"><strong aria-hidden="true">2.1.</strong> The Chase</a></li><li><a href="theory/implementation.html"><strong aria-hidden="true">2.2.</strong> Implementation</a></li></ol></li><li><a href="syntax.html"><strong aria-hidden="true">3.</strong> Syntax</a></li><li><ol class="section"><li><a href="syntax/variations.html"><strong aria-hidden="true">3.1.</strong> Syntactic Variations</a></li><li><a href="syntax/precedence.html"><strong aria-hidden="true">3.2.</strong> Connective Precedence</a></li><li><a href="syntax/grammar.html"><strong aria-hidden="true">3.3.</strong> Grammar</a></li></ol></li><li><a href="build.html"><strong aria-hidden="true">4.</strong> Build</a></li><li><a href="run.html"><strong aria-hidden="true">5.</strong> Run</a></li><li><ol class="section"><li><a href="run/bounded.html"><strong aria-hidden="true">5.1.</strong> Bounded Model-Finding</a></li><li><a href="run/scheduler.html"><strong aria-hidden="true">5.2.</strong> Model-Finding Scheduler</a></li></ol></li><li><a href="example.html"><strong aria-hidden="true">6.</strong> Example</a></li><li><ol class="section"><li><a href="example/valar-morghulis.html"><strong aria-hidden="true">6.1.</strong> Valar Morghulis</a></li><li><a href="example/golden-head.html"><strong aria-hidden="true">6.2.</strong> Golden Head</a></li><li><a href="example/hold-the-door.html"><strong aria-hidden="true">6.3.</strong> Hold the Door</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">rusty-razor</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#razor" id="razor"><h1>Razor</h1></a>
<p><a href="https://github.com/salmans/rusty-razor">Razor</a> is a <a href="https://en.wikipedia.org/wiki/First-order_logic">first-order</a> model-finder. Given an input first-order theory, corresponding to the design specification of
a system, written in Razor's <a href="https://salmans.github.io/rusty-razor/syntax.html">input syntax</a>,
Razor constructs a set of models as examples of the system's execution. The output set of models may contain examples that
are consistent with the user's expectation and support the system's design. They may also contain surprising examples of
unexpected behavior, which reveal potential logical flaws in the specification. Razor produces no models if the input
theory is logically inconsistent.</p>
<p>==TODO: point to examples==</p>
<p>As a first-order model-finder, Razor is comparable to tools like <a href="https://emina.github.io/kodkod/">Kodkod</a>, <a href="https://www.mcs.anl.gov/research/projects/AR/mace">MACE</a>, and <a href="http://vlsicad.eecs.umich.edu/BK/Slots/cache/www.cs.chalmers.se/%7Ekoen/paradox">Paradox</a>. Kodkod, is the underlying
model-finding engine of <a href="http://alloytools.org">Alloy Analyzer</a>, a modeling tool that has gained increasing recognition in the software industry,
thanks to its intuitive language and well-crafted analysis tool. Inspired by Kodkod and Alloy, the goal of Razor is to make
&quot;lightweight formal methods&quot; accessible to the general software development community, serving as a model-finding engine for
domain specific analysis tools.</p>
<blockquote>
<p><strong>Note:</strong>
First-order <em>model-finding</em> is often confused with temporal <em>model-checking</em>, also known as <em>property-checking</em>. Both
model-finding and model-checking are reasoning techniques that exhaustively verify properties of a system in a given search space;
however, model-checking is the practice of verifying temporal properties in a finite-state model of the system. In contrast,
model-finding refers to finding examples of the system's behavior by constructing models for its corresponding first-order specification.</p>
</blockquote>
<a class="header" href="print.html#conventional-model-finding" id="conventional-model-finding"><h2>Conventional Model-Finding</h2></a>
<p>It's a well-known result that first-order model-finding is undecidable (see <a href="https://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems">Gödel's incompleteness theorem</a>).
As a consequence, any practical model-finding algorithm must resort to some notion of <em>bound</em> on the search
space of models to guarantee termination. Conventional model-finders, such as Kodkod, MACE, and Paradox,
assume a bound on the size of the domain of models to be found. This assumption makes it possible to translate
the input first-order theory 𝓣 to a propositional formula 𝓟 up to the give bound. This process is known
as <em>propositionalization</em>. Next, the model-finder utilizes a <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">SAT</a> solver to find
solutions for 𝓟. Intuitively speaking, one might think of the propositionalization step as the process of
enumerating all potential models of the initial first-order formula where each propositional variable in 𝓟
represents a <em>fact</em> in first-order models of 𝓣. The job of the SAT solver is to find solutions to 𝓟,
corresponding to images of first-order models for 𝓣. Finally, the model-finder maps the solutions to the
SAT problem back to models of the original first-order theory 𝓣.</p>
<p><a name="list_example"></a>
For example, consider the following specification of a conventional list in functional
programming languages:</p>
<pre><code>// Every list `x` is `'nil` or points to a `next` list:
∀ x . List(x) → x = 'nil ∨ ∃ y. next(x) = y and List(y);

// The `next` of a list is its sublist:
∀ x, y. next(x) = y → Sublist(x, y);
// The `next` of a sublist is itself a sublist:
∀ x, y, z. Sublist(x, y) ∧ next(y) = z → Sublist(x, z);

// `'nil` never point to a `next` list:
~∃ x. next('nil) = x;
// A list cannot be its own sublist (no cycles):
~∃ x. Sublist(x, x);

// `'my_list` is a list:
List('my_list);
</code></pre>
<p>The first five formulae of this theory describe the list data structure and the last formula asks for models
with a list, namely <code>'my_list</code>. Given a bound of 4 on the size of the models, a conventional model-finder
queries the underlying SAT solver for solutions consisting of 1, 2, 3, or 4 elements (e.g., lists) that satisfy
the theory. Consequently, the model-finder may spit out solutions such as the following (○, ●, and ⟶ respectively
denote the <code>'nil</code> list, a non-empty list, and the <code>next</code> function):</p>
<ul>
<li>
<p><code>'my_list</code> of length 0 (i.e., the <code>'nil</code> list):</p>
<p><code>'my_list</code>:  ◯</p>
</li>
<li>
<p><code>'my_list</code> of length 1 (a node pointing to <code>'nil</code>):</p>
<p><code>'my_list</code>:  ⬤➝◯</p>
</li>
<li>
<p><code>'my_list</code> of length 2:</p>
<p><code>'my_list</code>:  ⬤➝⬤➝◯</p>
</li>
</ul>
<p><a name="list_example_bad_model"></a></p>
<ul>
<li>
<p>Two lists (<code>'my_list</code> and an unnamed list) of length 1:</p>
<p><code>'my_list</code>:   ⬤➝◯<br />
(unnamed):  ⬤➝◯</p>
</li>
<li>
<p><code>'my_list</code> of length 3 and a (unnamed) list of length 0:</p>
<p><code>'my_list</code>:   ⬤➝⬤➝⬤➝◯<br />
(unnamed):  ◯</p>
</li>
</ul>
<p>A key take-away is that the input bound on the model size does not only guarantee termination, but also is
<em>necessary</em> to make propositionalization generally possible.</p>
<blockquote>
<p><strong>Note:</strong>
Certain classes of first-order formulae including the <a href="https://en.wikipedia.org/wiki/Bernays%E2%80%93Sch%C3%B6nfinkel_class">Bernays–Schönfinkel–Ramsey class</a>,
also known as the <em>effectively propositional</em> (EPR) class, may be translated into propositional logic without
an explicit search bound.</p>
</blockquote>
<a class="header" href="print.html#razor-a-first-order-approach" id="razor-a-first-order-approach"><h2>Razor: A First-Order Approach</h2></a>
<p>Razor takes a direct approach to first-order model-finding without propositionalization and SAT solving.
The essence of Razor's algorithm is the <a href="https://en.wikipedia.org/wiki/Chase_(algorithm)">chase</a> from database theory. Our approach to model-finding has a
couple of primary advantages: first, the model-finding algorithm doesn't inherently require a bound for
propositionalization. Second, the algorithm can leverage information in first-order logic to guide the search
for models, unlike the SAT-based approach where the underlying SAT solver is put in charge of the search. However,
these features usually come at a performance cost as Razor doesn't make use of the blazingly fast modern SAT-solvers.</p>
<a class="header" href="print.html#a-nameunbounded-unbounded-algorithm" id="a-nameunbounded-unbounded-algorithm"><h3><a name="unbounded"/> Unbounded Algorithm</h3></a>
<p>As discussed earlier, SAT-based model-finders translate the input first-order theory to a propositional formula up to a bound,
which is often provided by the user. Providing a search bound that is sufficient for a complete analysis yet small enough to
make the search tractable poses a challenge to using SAT-based model-finders. Inferring a sufficient search bound to help the
user has been an ongoing research in the literature.</p>
<p>In contrast, Razor's model-finding algorithm is unbounded: starting from an <em>empty</em> model 𝕞 (i.e., a model over an empty
domain), Razor constructively augments 𝕞 with necessary elements and facts until 𝕞 satisfies the input theory or a
contradiction occurs. When there is more than one way to continue, the algorithm augments clones of 𝕞 in different search branches.</p>
<p>As a direct result of undecidability of first-order logic, a run of Razor on an arbitrary theory may fail to terminate.
To guarantee termination, we would need to devise a termination condition such an execution timeout, a count of generated models,
a maximum search depth, or possibly a bound on the domain size of models. Because of the inherent unboundedness of Razor's algorithm,
the user wouldn't have to provide the search bound upfront; in fact, the user may let the search continue for an arbitrary length of
time and kill the Razor's process on demand.</p>
<blockquote>
<p><strong>Note:</strong>
Some SAT-based model-finders like Paradox implement clever algorithms to reuse some components of the intermediate propositionalized
formula for a bound of size <code>n</code> to generate a propositional formula for a bound at <code>n + 1</code>. This approach enables the solver to perform
incremental model-finding as it expands the search bound. Nevertheless, at each step, a considerable portion of the previously generated
propositional formulae and the earlier work of the SAT-solver must get discarded.</p>
</blockquote>
<a class="header" href="print.html#controlled-search" id="controlled-search"><h3>Controlled Search</h3></a>
<p>Conventional model-finders put their (often off-the-shelf) SAT-solvers fully in charge of constructing structures
that are then translated to models of the input theory; therefore, the model-finding tool has little control over
the search algorithm. In particular, relying on a SAT-solver would limit the opportunities to guide the search and
optimize the quality of models.</p>
<p>Razor constructs models that are minimal with respect to their <em>information content</em> within a framework for <em>exploring</em>
the space of models of the input theory. In addition, employing a first-order search algorithm enables Razor to trivially
parallelize and distribute the search, give access to the intermediate <em>partial</em> models, and employ heuristics to guide the
search.</p>
<a class="header" href="print.html#a-nameminimality-minimality" id="a-nameminimality-minimality"><h4><a name="minimality"/> Minimality</h4></a>
<p>SAT-based model-finders tend to output <em>noisy</em> models: these are non-minimal models which hold <em>facts</em> that aren't necessary
for satisfying the input theory. Noisy models can be hard to understand as they don't offer <em>provenance</em>
for their content. In contrast, Razor's algorithm is guided towards producing <em>minimal</em> models, which contain nothing but facts
that must be present for satisfying the theory. Formally speaking, Razor returns models that are minimal with respect to a
<a href="https://en.wikipedia.org/wiki/Homomorphism">homomorphism</a> ordering on all models of the theory. The homomorphism ordering serves as a useful measure of information
content, enabling Razor to offer <em>provenance</em> to justify the content of its models by the sentences of the input theory.</p>
<p>Consider the <a href="./model-finding.html#list_example">list</a> specification from the previous section. A run of Razor bounded by a domain size of 4 elements outputs
models such as the ones below:</p>
<ul>
<li>
<p><code>'my_list</code> of length 0 (i.e., the <code>'nil</code> list):</p>
<p><code>'my_list</code>:  ◯</p>
</li>
<li>
<p><code>'my_list</code> of length 1:</p>
<p><code>'my_list</code>:  ⬤➝◯</p>
</li>
<li>
<p><code>'my_list</code> of length 0 (an alias for <code>'nil</code>) and an unnamed list of of length 1:</p>
<p><code>'my_list</code>:  ◯<br />
(unnamed):   ⬤➝◯</p>
</li>
<li>
<p><code>'my_list</code> of length 2:</p>
<p><code>'my_list</code>:  ⬤➝⬤➝◯</p>
</li>
<li>
<p><code>'my_list</code> of length 0 and an unnamed list of of length 2:</p>
<p><code>'my_list</code>:  ◯<br />
(unnamed):   ⬤➝⬤➝◯</p>
</li>
<li>
<p><code>'my_list</code> of length 3:</p>
<p><code>'my_list</code>:  ⬤➝⬤➝⬤➝◯</p>
</li>
</ul>
<p>All these models are minimal in the sense that unlike <a href="./model-finding.html#list_example_bad_model">some examples</a> from the previous section,
every peice of information in these models is required by the input theory and cannot be removed.</p>
<blockquote>
<p><strong>Note:</strong>
For every model 𝕟 of the input theory 𝓣, Razor returns a model 𝕞 with a homomorphism from 𝕞 to 𝕟. Informally,
it's always possible to construct any model of 𝓣 by adding more information to a model returned by Razor. Therefore, we
refer to the models returned by Razor as a <em>set of support</em> for 𝓣.</p>
</blockquote>
<a class="header" href="print.html#verification-and-exploration" id="verification-and-exploration"><h4>Verification and Exploration</h4></a>
<p>First-order model-finding is often applied to uncover inconsistencies and logical flaws where the user verifies if an assertion
follows from a specification. The assertion, which is often a desirable <em>property</em> of the system, holds if its negation is
inconsistent with the specification, having no models. I will refer to this mode of interaction with a model-finder as
<em>verification</em>. When working with a model-finder in the verification mode, only one (unexpected) model is sufficient to reveal
a bug in the specification.</p>
<p>In a different mode of analysis, the user understands models of the theory as instances of the behavior of a system specification.
I will call this mode of interaction with a model-finder <em>exploration</em>. Unlike the verification mode, where the model-finder helps
the user to prove properties of a system, the user of the exploration mode is interested in investigating examples of a system's
execution without necessarily having specific properties in mind. The goal of exploration is to help the user develop a better
understanding of the specified system.</p>
<blockquote>
<p><strong>Note:</strong>
<code>check</code> and <code>run</code> commands in Alloy operate in verification and exploration modes respectively.</p>
</blockquote>
<p>SAT-based model-finders commonly offer models in no particular order as the order of output is dictated by the underlying
SAT-solver. This behavior is often acceptable in the verification mode, where any counterexample suffices to disprove a hypothesis
or invalidate a property. In contrast, effective model-finding for exploration greatly benefits from a systematic approach to
presenting models, an exploration method that enables the user to effectively navigate through various classes of (possibly many)
models of the theory and does not solely rely on the serendipity of SAT-solving. Razor's approach to model-finding offers a solution!</p>
<p>As I mentioned in the <a href="print.html#minimality">previous section</a>, Razor produces models that are minimal with no noise, i.e., unnecessary facts.
More accurately, these are models that are minimal with respect to a preorder ≺ induced by the homomorphism relation
between the models of the theory. For two models 𝕞 and 𝕟 of a theory
𝓣, 𝕞 ≺ 𝕟 if and only if there is a homomorphism from 𝕞 to 𝕟 and it's easy to show that 𝕞 contains less noise than 𝕟.
It is, though, always possible to <em>augment</em> 𝕞 with additional (unnecessary) facts to obtain 𝕟. This is the core principle that
enables a framework for model exploration with respect to a measure of information content.</p>
<blockquote>
<p><strong>Note:</strong>
<a href="https://dl.acm.org/doi/10.5555/2486788.2486820">Aluminum</a> is a preliminary realization of this approach to exploring models, which was implemented as a modification of Alloy.</p>
</blockquote>
<a class="header" href="print.html#fitness" id="fitness"><h4>Fitness</h4></a>
<p>Model-finders could potentially incorporate heuristic measures to prioritize specific search branches or adopt various search strategies.
However, delegating the search to a SAT-solver dramatically limits the opportunity for taking advantage of heuristics and contextual
information.</p>
<p>Earlier, I brought up <a href="print.html#minimality">minimality</a> as a quality measure but the user might be interested in other attributes and criteria
for model exploration. For example, the user could ask for a new model that is less similar to the ones previously returned or one that
would be &quot;surprising&quot;. Also, the model-finder may keep track of various heuristics to deprioritize search branches that are more likely
to fail or to switch between different scheduling algorithms.</p>
<a class="header" href="print.html#geometric-logic" id="geometric-logic"><h1>Geometric Logic</h1></a>
<p>Razor implements a variant of <a href="./theory/chase.html">the chase</a> algorithm to construct models for theories in
<a href="https://www.cs.bham.ac.uk/%7Esjv/GLiCS.pdf">geometric logic</a>, a syntactic variation of first-order logic. Geometric theories
are comprised of geometric <em>sequents</em> in the following form:</p>
<pre>
𝙰<sub>1</sub> ∧ ... ∧ 𝙰<sub>m</sub> ⊢<sub>𝘅</sub> (∃ 𝚢<sub>11</sub>, ..., 𝚢<sub>1j<sub>1</sub></sub> . 𝙰<sub>11</sub> ∧ ... ∧ 𝙰<sub>1n<sub>1</sub></sub>)  
              ∨ (∃ 𝚢<sub>21</sub>, ..., 𝚢<sub>2j<sub>2</sub></sub> . 𝙰<sub>21</sub> ∧ ... ∧ 𝙰<sub>2n<sub>2</sub></sub>)  
              ∨ ...  
              ∨ (∃ 𝚢<sub>i1</sub>, ..., 𝚢<sub>ij<sub>i</sub></sub> . 𝙰<sub>i1</sub> ∧ ... ∧ 𝙰<sub>in<sub>i</sub></sub>)
</pre>
<p>where ⊢ denotes logical entailment, 𝙰<sub>k</sub>s are atomic formulae (including equality),
and 𝘅 is the set of free variables (assumed to be universally quantified) in the sequent. The premise
(left side) and the consequence (right side) of ⊢ are respectively said to be the <em>body</em> and the <em>head</em> of
the sequent. A body of empty conjunctions (m = 0) and a head of empty disjunctions (i = 0) are equivalent to
truth (⊤) and falsehood (⟘) respectively.</p>
<a class="header" href="print.html#satisfiability" id="satisfiability"><h3>Satisfiability</h3></a>
<p>It turns out that a first-order theory 𝓣 can be transformed to a geometric theory 𝓖 that is
<a href="https://en.wikipedia.org/wiki/Equisatisfiability"><em>equisatisfiable</em></a> to 𝓣 via standard syntactic manipulation. That is, 𝓣 is satisfiable
(i.e., has a model) if and only if 𝓖 is satisfiable. But 𝓖 has other desirable properties that
goes beyond equisatisfiability with 𝓣: in fact, for every model 𝕟 of 𝓣, a model 𝕞 of 𝓖 exists
such that there is a homomorphism from 𝕞 to 𝕟. This is an important result that enables Razor
to apply the chase to construct homomorphically <a href="./razor.html#minimality">minimal</a> models of 𝓣.</p>
<p>In the context of a model-finding application, the chase constructs special models that contain
minimum amount of information required for satisfying the input theory. Equisatisfiability of
geometric and first-order logic also implies that satisfiability of geometirc theories is
undecidable (see <a href="https://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems">Gödel's incompleteness theorems</a>).</p>
<blockquote>
<p><strong>Note:</strong> Chapter 4 of my doctoral <a href="https://digital.wpi.edu/concern/etds/5q47rn87k">dissertation</a> presents a comprehensive discussion about
geometric logic and the chase.</p>
</blockquote>
<a class="header" href="print.html#the-chase" id="the-chase"><h2>The Chase</h2></a>
<p>The <a href="https://en.wikipedia.org/wiki/Chase_(algorithm)">chase</a> is a well-known algorithm in database theory that constructs models for geometric theories.
Given a geometric theory 𝓖 and starting with an empty model 𝕞, a run of the chase consists of repeated
applications of the <a href="print.html#step">chase-step</a> to augment 𝕞 with <em>necessary</em> information until there is a
contradiction or 𝕞 satisfies 𝓖. Inspired by <a href="https://www.cs.bham.ac.uk/%7Esjv/GeoZ.pdf">Steven Vickers</a>, we refer to the units of information
for augmenting models as <em>observations</em>.</p>
<a class="header" href="print.html#a-namestepchase-stepa" id="a-namestepchase-stepa"><h3><a name="step">Chase-Step</a></h3></a>
<p>Given a geometric theory 𝓖 and a model 𝕞, a chase-step proceeds as below:</p>
<ol>
<li>
<p>A sequent 𝜑 ⊢<sub>𝘅</sub> 𝜓 from 𝓖 is selected for evaluation.</p>
</li>
<li>
<p>Given an assignment from the variables in 𝘅 to the elements of 𝕞: if 𝜑 is true and 𝜓 is false in 𝕞,
new observations are added to 𝕞 to make 𝜓 true, such that:</p>
<ul>
<li>
<p>If 𝜓 is equal to ⟘ (i.e., an empty disjunction), the chase fails on 𝕞.</p>
</li>
<li>
<p>If 𝜓 contains more than one disjunct, namely 𝜓<sub>1</sub> ∨ ... ∨ 𝜓<sub>i</sub> (i &gt; 1),
the chase branches and augments clones of 𝕞 to make 𝜓<sub>i</sub> true in each branch.</p>
</li>
<li>
<p>If there is no sequent such that 𝜑 is true and 𝜓 is false in 𝕞, the model 𝕞 already satisfies
𝓖 and is returned as an output.</p>
</li>
</ul>
</li>
</ol>
<a class="header" href="print.html#termination" id="termination"><h3>Termination</h3></a>
<p>It can be shown a run of the chase always terminates on an unsatisfiable theory, although it may take
a very very long time. However, when the theory is satisfiable, a run of the chase may not terminate,
producing infinitely large and/or infinitely many models. This is consistent with semi-decidability
of the satisfiability problem for first-order theories.</p>
<blockquote>
<p><strong>Note:</strong> As discussed <a href="./razor.html#unbounded">earlier</a>, Razor accepts a search bound to guarantee termination
of the chase.</p>
</blockquote>
<a class="header" href="print.html#implementation" id="implementation"><h2>Implementation</h2></a>
<p>Razor's model-finding algorithm is a variant of <a href="./theory/chase.html">the chase</a>, an
algorithm for constructing models for geometric theories. Given an
input first-order theory 𝓣, Razor applies a standard syntactic
transformation to convert 𝓣 to a <em>Geometric Normal Form</em> (GNF). The
result of this transformation is a geometric theory 𝓖 that is
equisatisfiable with 𝓣.</p>
<blockquote>
<p><strong>Note:</strong> Transformation to GNF consists of transforming the input
theory to a <a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form#Converting_from_first-order_logic">Conjunctive Normal Form</a> (CNF) followed by
rearranging the conjuncts of the resulting CNF into an implication,
where negative and positive conjuncts form the implication's premise
and consequence respectively. The implication is semantically
equivalent to a geometric sequence and is treated as such.</p>
<p>It's noteworthy that conversion to CNF involves
<a href="https://en.wikipedia.org/wiki/Skolem_normal_form"><em>Skolemization</em></a>, a transformation by which existential
quantifiers of the input theory are replaced with fresh &quot;Skolem
functions&quot;. Therefore, the resulting GNF is a theory over an extension
of the original vocabulary over which the input theory is defined.</p>
</blockquote>
<p>Let 𝓖 be an input geometric theory. The essense of a
<a href="./theory/chase.html#step">chase-step</a> on a model 𝕞 is to find a sequent 𝜑 ⊢<sub>𝘅</sub> 𝜓
of 𝓖 with an assignment from the variables in 𝘅 to the domain of 𝕞
such that 𝜑 is true and 𝜓 is false in 𝕞. A naive implementation of the
chase would iterate over all sequents of 𝓖 and examine every
assignment from 𝘅 to the domain of 𝕞. This would lead to |𝘅|<sup>|𝕞|</sup> valuations of 𝜑 and 𝜓 in 𝕞 where |𝘅| and |𝕞|
denote the size of 𝘅 and the domain size of 𝕞 respectively. Such a
naive implementation is extremely inefficient for practical
model-finding use-cases.</p>
<p>A practical implementation of the chase must address a number of
algorithmic challenges: it must provide efficient data-structures for
querying models and keeping track of various search branches; it
should implement effective heuristics for choosing a search branch and
for selecting a sequent to evaluate; and most importantly, it must
implement a fast solution for finding assignments from the free
variables in 𝘅 to the elements of 𝕞.</p>
<a class="header" href="print.html#a-namecodd-hello-codd" id="a-namecodd-hello-codd"><h3><a name="codd"/> Hello Codd!</h3></a>
<p><a href="https://en.wikipedia.org/wiki/Codd%27s_theorem">Codd's theorem</a> is a well known result from database theory
that establishes equivalence between <a href="https://en.wikipedia.org/wiki/Relational_algebra">relational algebra</a> and
<a href="https://en.wikipedia.org/wiki/Relational_calculus">relational calculus</a> thus first-order logic.  Razor takes
advantage of this equivalence to implement the chase efficiently with
the help of database theory. From a database perspective, a model 𝕞
constructed by the chase can be thought of as a monotonically growing
database with relational tables for each predicate of the input theory
𝓖. Consequently, positive existential formulae are expressed queries
with conjunction (∧), disjunction (∨), and existential quantifier (∃)
acting as relational join (⋈), set union (∪), and projection (∏).
Finally, a geometric sequent 𝜑 ⊢<sub>𝘅</sub> 𝜓 is evaluated by a query
𝛷 - 𝛹, the set difference of the relational expressions corresponding
to 𝜑 and 𝜓. Intuitively, evaluating 𝛷 - 𝛹 in 𝕞 results in a set of
tuples that assign values to the variables in 𝘅 such that 𝜑 is true
and 𝜓 is false, as required by the chase-step. After evaluating 𝛷 -
𝛹, the chase-step proceeds by inserting the resulting tuples in the
relations mentioned by 𝛹, thus, making 𝜓 true in 𝕞.</p>
<p>Razor's implementation of the chase uses <a href="https://github.com/salmans/codd"><code>codd</code></a>, a minimal
in-memory database with relational expressions as queries. The
underlying database abstraction would enable Razor to take advantage
of many advances in database theory and particularly streaming
databases to run more efficiently.  For example, <code>codd</code> supports
incrementally updated materialized views that are used to avoid full
re-evaluation of expressions during a run of the chase as the
database (i.e., the model 𝕞) grows.</p>
<a class="header" href="print.html#relationalization" id="relationalization"><h4>Relationalization</h4></a>
<p>The algorithm based on relational algebra requires a relationalization
step to transform a given first-order theory 𝓣 with function symbols
to an equivalent theory 𝓣′ without functions.  Relationalization is a
standard transformation that involves flattening of complex terms
followed by replacing function symbols and constants (i.e., nullary
functions) with new predicates. This transformation also extends the
original theory with integrity axioms that preserve the semantics of
the eliminated functions.</p>
<p>A discussion about the details of relationalization is out of the
scope of this document. Here, I use an example to explain the core
idea. Consider the atomic formula below, where 𝚁 is a predicate, 𝚏 and
𝚐 are function symbols, 𝚡 and 𝚢 are variables, and 𝗰 is a constant:</p>
<p>𝚁(𝚏(𝚐(𝚡), 𝚢), 𝗰)</p>
<p>To flatten this formula, we introduce fresh variables, namely
𝚟<sub>1</sub>, 𝚟<sub>2</sub>, and 𝚟<sub>3</sub> to recursively replace
complex terms, consisting of function applications and
constants. Notice that the original and the flattened formulae are
semantically equivalent:</p>
<p>𝚁(𝚟<sub>1</sub>, 𝚟<sub>2</sub>) ∧ 𝚏(𝚟<sub>3</sub>, 𝚢) = 𝚟<sub>1</sub>
∧ 𝚐(𝚡) = 𝚟<sub>3</sub> ∧ 𝗰 = 𝚟<sub>2</sub></p>
<p>Next, for each function symbol of arity 𝚗, we introduce a predicate of
arity 𝚗 + 1 and replace the equalities between function applications
and variables with atomic formulae over the new predicates:</p>
<p>𝚁(𝚟<sub>1</sub>, 𝚟<sub>2</sub>) ∧ 𝙵(𝚟<sub>3</sub>, 𝚢, 𝚟<sub>1</sub>) ∧
𝙶(𝚡, 𝚟<sub>3</sub>) ∧ 𝙲(𝚟<sub>2</sub>)</p>
<p>In the previous example, 𝙵, 𝙶, and 𝙲 replace 𝚏, 𝚐, and 𝗰 in that
order.  The last position of these predicates correspond to the output
of the functions that they replace. Finally, to preserve the semantics
of the eliminated functions, the following sequents are added to the
resulting theory 𝓣′:</p>
<p>𝙵(𝚡<sub>1</sub>, 𝚡<sub>2</sub>, 𝚢) ∧ 𝙵(𝚡′<sub>1</sub>, 𝚡′<sub>2</sub>,
𝚢′) ∧
𝚡<sub>1</sub> = 𝚡′<sub>1</sub> ∧ 𝚡<sub>2</sub> = 𝚡′<sub>2</sub> ⊢ 𝚢 = 𝚢′<br />
𝙶(𝚡, 𝚢) ∧ 𝙶(𝚡′, 𝚢′) ∧ 𝚡 = 𝚡′ ⊢ 𝚢 = 𝚢′<br />
𝙲(𝚢) ∧ 𝙲(𝚢′) ⊢ 𝚢 = 𝚢′</p>
<p>These sequents ensure that the new predicates are interpreted by
relations that map every vector of input arguments to exactly one
output, as the original functions do.</p>
<blockquote>
<p><strong>Note:</strong> It's common to add another set of sequents to the
resulting relationalized theory to preserve the totality of
functions. The chase, however, interprets the functions of the input
theory as partial functions; therefore, we're not concerned with
preserving totality.</p>
</blockquote>
<a class="header" href="print.html#a-nameequality-equality" id="a-nameequality-equality"><h4><a name=equality/> Equality</h4></a>
<p>Interpreting equality as a relation can be done by axiomatizing
equality as a predicate, captured by the following sequents with = as
a special binary predicate symbol:</p>
<pre> 
⊤ ⊢ =(x, x)                (reflexivity) 
=(𝚡, 𝚢) ⊢ =(𝚢, 𝚡)           (symmetry) 
=(𝚡, 𝚢) ∧ =(𝚢, 𝚣) ⊢ =(𝚡, 𝚣) (transitivity) 
</pre>
<blockquote>
<p><strong>Note:</strong> Our treatment of equality takes advantage of the fact that
equality axioms can be expressed as geometric sequents.</p>
</blockquote>
<a class="header" href="print.html#variable-linearization" id="variable-linearization"><h4>Variable Linearization</h4></a>
<p>The translation to relational algebra must account for a number of
practical challenges regarding variables and their order of appearance
in formulae. From a database perspective, each position on the
first-order predicates represents a relational <em>attribute</em> (i.e., a
column of a relational table).  Therefore, the variables of the
formulae in the input theory enforce equality constraints on the
resulting select query. Specifically, the positions of two conjoined
predicates that are occupied by the same variable specify the <em>key
attributes</em> of a relatoinal join where equality between join
attributes is defined by the relation = from the <a href="print.html#equality">previous
section</a>. As a result, Razor applies a standard
<em>linearization</em> transformation that assigns unique names to variables
that occupy positions on any predicate except for =. When renaming
variables, linearization introduces additional equalities between the
freshly introduced unique variables that rename the same variable in
the input formula.</p>
<p>Now, I will use another example to describe linearization:</p>
<p>𝙿(𝚡) ∧ 𝚀(𝚢, 𝚡, 𝚢)</p>
<p>A possible linearized version of the formula above is obtained by
renaming the second occurances of x and 𝚢, in 𝚀(𝚢, 𝚡, 𝚢), with new
variables, namely x<sub>0</sub> and 𝚢<sub>0</sub>. In addition, =(x,
x<sub>0</sub>) and =(𝚢, 𝚢<sub>0</sub>) are conjoined into the formula
to preserve equality between a variable and its renaming counterpart:</p>
<p>𝙿(𝚡) ∧ 𝚀(𝚢, 𝚡<sub>0</sub>, 𝚢<sub>0</sub>) ∧ =(x, x<sub>0</sub>) ∧ =(𝚢,
𝚢<sub>0</sub>)</p>
<a class="header" href="print.html#range-restriction" id="range-restriction"><h4>Range Restriction</h4></a>
<p>I mentioned <a href="print.html#codd">earlier</a> that in our implementation of the chase
based on relational algebra, a sequent 𝜑 ⊢<sub>𝘅</sub> 𝜓 is evaluated
as a relational expression 𝛷 - 𝛹 where 𝛷 and 𝛹 are relational
expression obtained by transforming 𝜑 and 𝜓. The set difference
operator is defined only when the attributes of 𝛷 and 𝛹 align; that
is, they must share the same attributes in the same order. If 𝛷 and 𝛹
share the same set of attributes but in different orders, it's always
possible to project either of the expressions to match the order of
attributes. If 𝛷 and 𝛹 have different attributes, two cases are
possible:</p>
<ol>
<li>An attribute 𝜶 appears in 𝛷 but not in 𝛹. In this case, we simply
project 𝜶 out of 𝛷.</li>
<li>An attribute 𝜷 appears in 𝛹 but not in 𝛷. The treatment for this
case involves <em>range restriction</em> as described below.</li>
</ol>
<p>In database theory, a range-restricted query</p>
<blockquote>
<p>talk about other implementations</p>
</blockquote>
<a class="header" href="print.html#syntax" id="syntax"><h1>Syntax</h1></a>
<p>The syntax and semantics of Razor's input is that of conventional
<a href="https://en.wikipedia.org/wiki/First-order_logic">first-order logic</a>,
also known as predicate logic.</p>
<p>Razor's input supports three <a href="./syntax/variations.html">syntactic variations</a>
for the logical symbols and follows one of the more predominant conventions for
the <a href="./syntax/precedence.html">precedence</a> of the logical connectives.
For consistency and readability purposes, we use the <em>alpha</em> variation
everywhere in this document.</p>
<a class="header" href="print.html#identifier" id="identifier"><h2>Identifier</h2></a>
<p>Lowercase and uppercase identifiers in Razor are defined by the following:</p>
<ul>
<li>A <em>lowercase</em> identifier is a word starting with either a lowercase alphabetic character (<code>[a-z]</code>) or
the underscore (<code>_</code>), followed by any number of alphanumeric characters (<code>[a-zA-Z0-9]</code>) and/or the
underscore. For example, <code>rusty</code>, <code>_razor</code>, and <code>rusty123_RAZOR456</code> are lowercase identifiers.</li>
<li>An <em>uppercase</em> identifier is a word that starts with an uppercase alphabetic character (<code>[A-Z]</code>) and
is followed by any number of alphanumeric characters (<code>[a-zA-Z0-9]</code>) and/or the underscore (<code>_</code>).
For example, <code>Rusty</code>, and <code>RAZOR_123</code> are uppercase identifiers.</li>
</ul>
<a class="header" href="print.html#term" id="term"><h2>Term</h2></a>
<p>A <em>term</em> in Razor's input is a conventional first-order term, inductively defined by the following:</p>
<ul>
<li>A <strong>variable</strong> is a lowercase identifier, and it is a term on its own. For example, <code>v</code>,
<code>variable</code>, and <code>_var</code> may be used as variable symbols.</li>
<li>A <em>composite</em> term consists of a lowercase identifier as a <strong>function</strong> symbol that is applied
to zero or more terms as arguments that are wrapped in parentheses. For example, <code>f()</code>, <code>f(a)</code>,
<code>f(g(a, b), c)</code>, and <code>func(plus(x, y))</code> are terms.</li>
</ul>
<p>Razor treats <em>nullary</em> functions (of arity zero that take no arguments)
as <strong>constants</strong>. An apostrophe (<code>'</code>) followed by a lowercase identifier is a syntactic sugar
for constructing a constant. For example, <code>'a</code> is a constant that is syntactically
equivalent to <code>a()</code>.</p>
<a class="header" href="print.html#a-nameformulaformulaa" id="a-nameformulaformulaa"><h2><a name=formula>Formula</a></h2></a>
<p>A <em>formula</em> in Razor's input is a conventional first-order formula <em>with equality</em>, inductively
defined by the following:</p>
<ul>
<li>
<p>An <strong>atomic</strong> formula consists of an upper case identifier as a <strong>predicate</strong> symbol that is
applied to zero or more terms as arguments that are wrapped in parentheses. For example, <code>R()</code>,
<code>R(x)</code>, and <code>R(f(x, 'a), y, 'b)</code> are atomic formulae.</p>
</li>
<li>
<p>An <strong>equality</strong> is a especial type of atomic formula, with a binary infix connective <code>=</code> that is
applied on two terms as its arguments. Razor treats an equality as identity between its arguments.
For example, <code>x = y</code>, and <code>f(x) = g(f(y), 'a)</code> are equalities.</p>
</li>
<li>
<p>The result of applying the logical connectives <code>and</code>, <code>or</code>, <code>implies</code> and <code>iff</code> as infix binary
connectives to two fromulae is itself a formula. Parentheses may be used to override the conventional
<a href="./syntax/precedence.html">precedence</a> of the connectives.
For example <code>P(x) and x = y</code>, <code>P(x) and (Q(y) or R(x))</code>, and <code>P(x, y) implies x = y and R(z)</code>
are formulae.</p>
</li>
<li>
<p>The result of applying the logical connectives <code>forall</code> and <code>exists</code> to one or more comma (<code>,</code>)
separated <em>bound</em> variables and a formula, as a propositional function, is itself a formula. The
list of bound variables and the propositional function are separated by a period (<code>.</code>).
For example, <code>exists x. P(x)</code>, <code>forall x, y . Q(x, y) or R(z)</code>, and
<code>forall x. exists y. P(x, y)</code> are formulae.</p>
</li>
</ul>
<blockquote>
<p><strong>Note:</strong> A variable that is not bound by a universal (<code>forall</code>) or existential (<code>exists</code>) quantifier
is said to be a <em>free</em> variable. Razor assumes all free variables to be universally
quantified over the entire formula in which they appear.
For example, <code>P(x) -&gt; exists y . Q(x, y)</code> is assumed to be equivalent to
<code>forall x . (P(x) -&gt; exists y . Q(x, y))</code>.</p>
</blockquote>
<a class="header" href="print.html#input" id="input"><h2>Input</h2></a>
<p>Razor's input is a first-order theory, consisting of a list of zero or more formulae, separated by
the semi-colon (<code>;</code>). The input may contain conventional C-style comments (<code>//</code> for comment lines and
<code>/*</code> and <code>*/</code> for comment blocks). Whitespaces including new lines are allowed.
See the following input for an example:</p>
<pre><code>// equality axioms

forall x . x = x; /* Reflexitivity */
forall x, y . (x = y implies y = x); /* Symmetry */
forall x, y, z . (x = y and y = z implies x = z); /* Transitivity */
</code></pre>
<a class="header" href="print.html#syntactic-variations" id="syntactic-variations"><h2>Syntactic Variations</h2></a>
<p>Razor supports three syntactic variations of the logical symbols in the input:</p>
<ul>
<li><strong>alpha</strong> where logical symbols are written as alphabetic words.</li>
<li><strong>compact</strong> where ASCII notations represent logical symbols.</li>
<li><strong>math</strong> where (Unicode) mathematical symbols are used.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> Currently, Razor's parser accepts inputs that are comprised of any combination
of the syntactic variations mentioned above. However, future releases of Razor may restrict
the input to use only one of the variations above.</p>
</blockquote>
<p>The table below shows all syntactic variations of the logical symbols:</p>
<table><thead><tr><th> symbol                   </th><th align="center"> alpha      </th><th align="center"> compact                          </th><th align="center"> math         </th></tr></thead><tbody>
<tr><td> <em>truth</em>                  </td><td align="center"> <code>true</code>     </td><td align="center"> <code>'|'</code>            </td><td align="center"> <code>⊤</code> (U+22A4) </td></tr>
<tr><td> <em>falsehood</em>              </td><td align="center"> <code>false</code>    </td><td align="center"> <code>_|_</code>    </td><td align="center"> <code>⟘</code> (U+27D8) </td></tr>
<tr><td> <em>negation</em>               </td><td align="center"> <code>not</code>      </td><td align="center"> <code>~</code>                              </td><td align="center"> <code>¬</code> (U+00AC) </td></tr>
<tr><td> <em>conjunction</em>            </td><td align="center"> <code>and</code>      </td><td align="center"> <code>&amp;</code>                              </td><td align="center"> <code>∧</code> (U+2227) </td></tr>
<tr><td> <em>disjunction</em>            </td><td align="center"> <code>or</code>       </td><td align="center"> <code>|</code>              </td><td align="center"> <code>∨</code> (U+2228) </td></tr>
<tr><td> <em>implication</em>            </td><td align="center"> <code>implies</code>  </td><td align="center"> <code>-&gt;</code>                             </td><td align="center"> <code>→</code> (U+2192) </td></tr>
<tr><td> <em>bi-implication</em>         </td><td align="center"> <code>iff</code>      </td><td align="center"> <code>&lt;=&gt;</code>                            </td><td align="center"> <code>⇔</code> (U+21D4) </td></tr>
<tr><td> <em>existential quantifier</em> </td><td align="center"> <code>exists</code>   </td><td align="center"> <code>?</code>                              </td><td align="center"> <code>∃</code> (U+2203) </td></tr>
<tr><td> <em>universal quantifier</em>   </td><td align="center"> <code>forall</code>   </td><td align="center"> <code>!</code>                              </td><td align="center"> <code>∀</code> (U+2200) </td></tr>
</tbody></table>
<a class="header" href="print.html#connective-precedence" id="connective-precedence"><h2>Connective Precedence</h2></a>
<p>When a formula contains two or more logical connectives, the connectives
are applied by the following order from the highest to the lowest precedence:</p>
<ul>
<li>Negation (<code>not</code>) is applied first.</li>
<li>Conjunction (<code>and</code>) is applied next.</li>
<li>Disjunction (<code>or</code>) is applied next.</li>
<li>Implication (<code>implies</code>) and bi-implication (<code>iff</code>) are applied next.</li>
<li>Existential (<code>exists</code>) and universal (<code>forall</code>) quantifiers are applied last.</li>
</ul>
<p>A connective with a higher precedence is applied before a consecutive
connective with a lower precedence; that is, the connective with the higher
precedence binds tighter to the formula on which it operates.
For example, <code>P() implies not Q() and R()</code> is a formula consisting of
an implication where <code>P()</code> is the premise and the conjunction of <code>not Q()</code>
and <code>R()</code> is the consequence.</p>
<p>Parentheses may be used to override the precedence of connectives.
For example, in <code>P() and (Q() or R())</code> the disjunction (<code>or</code>) is applied before
the conjunction (<code>and</code>).</p>
<a class="header" href="print.html#associativity" id="associativity"><h3>Associativity</h3></a>
<p>All binary connectives of equal precedence except for implication
(<code>implies</code>) and bi-implication (<code>iff</code>) are left-associative.
For example, <code>P() | Q() | R()</code> is evaluated as <code>(P() | Q()) | R()</code>.</p>
<p>Implication and bi-implication are right-associative.
For example, <code>P() &lt;=&gt; Q() -&gt; R() &lt;=&gt; S()</code> is evaluated as
<code>P() &lt;=&gt; (Q() -&gt; (R() &lt;=&gt; S()))</code>.</p>
<a class="header" href="print.html#grammar" id="grammar"><h2>Grammar</h2></a>
<p>The input theory accepted by Razor is defined by the grammar below:</p>
<pre><code>LOWER       ::= [a-z_][a-zA-Z0-9_]*
UPPER       ::= [A-Z][a-zA-Z0-9_]*

TRUE        ::= &quot;true&quot;    | &quot;'|'&quot; | &quot;⊤&quot; (U+22A4)
FALSE       ::= &quot;false&quot;   | &quot;_|_&quot; | &quot;⟘&quot; (U+27D8)
NOT         ::= &quot;not&quot;     | &quot;~&quot;   | &quot;¬&quot; (U+00AC)
AND         ::= &quot;and&quot;     | &quot;&amp;&quot;   | &quot;∧&quot; (U+2227)
OR          ::= &quot;or&quot;      | &quot;|&quot;   | &quot;∨&quot; (U+2228)
IMPLIES     ::= &quot;implies&quot; | &quot;-&gt;&quot;  | &quot;→&quot; (U+2192)
IFF         ::= &quot;iff&quot;     | &quot;&lt;=&gt;&quot; | &quot;⇔&quot; (U+21D4)
EXISTS      ::= &quot;exists&quot;  | &quot;?&quot;   | &quot;∃&quot; (U+2203)
FORALL      ::= &quot;forall&quot;  | &quot;!&quot;   | &quot;∀&quot; (U+2200)

VARIABLE    ::= LOWER
FUNCTION    ::= LOWER
PREDICATE   ::= UPPER
VARIABLES   ::= VARIABLE (&quot;,&quot; VARIABLES)*
TERM        ::= VARIABLE | FUNCTION &quot;(&quot; TERMS? &quot;)&quot;
TERMS       ::= TERM (&quot;,&quot; TERMS)*

ATOM        ::= TRUE | FALSE
              | TERM &quot;=&quot; TERM | PREDICATE &quot;(&quot; TERMS? &quot;)&quot;
              | &quot;(&quot; FORMULA &quot;)&quot;
F_NOT        ::= NOT F_QUANTIFIED | ATOM
F_AND        ::= F_NOT (AND F_QUANTIFIED)?
F_OR         ::= F_AND (OR F_QUANTIFIED)?
F_QUANTIFIED ::= (EXISTS | FORALL) VARIABLES &quot;.&quot; F_QUANTIFIED | F_OR
FORMULA      ::= F_QUANTIFIED ((IMPLIES | IFF) F_QUANTIFIED)*

THEORY       ::= (FORMULA &quot;;&quot;)*
</code></pre>
<a class="header" href="print.html#build" id="build"><h1>Build</h1></a>
<p>rusty-razor is written in Rust, so you will need <a href="https://www.rust-lang.org">Rust</a> 1.37.0 or newer to compile it.
To build rusty-razor:</p>
<pre><code>git clone https://github.com/salmans/rusty-razor.git
cd rusty-razor
cargo build --release
</code></pre>
<p>This puts rusty-razor's executable in <code>/target/release</code>.</p>
<a class="header" href="print.html#run" id="run"><h1>Run</h1></a>
<a class="header" href="print.html#solve" id="solve"><h2><code>solve</code></h2></a>
<p>Use the <code>solve</code> command to find models for an input theory. The <code>-i</code> (short for <code>--input</code>)
reads the input from a file:</p>
<pre><code>razor solve -i &lt;input&gt;
</code></pre>
<blockquote>
<p>Run <code>solve</code> without the <code>-i</code> option to read the input from the standard input.</p>
</blockquote>
<p>The <code>--count</code> parameter limits the number of models to construct:</p>
<pre><code>razor solve -i &lt;input&gt; --count &lt;number&gt;
</code></pre>
<a class="header" href="print.html#bounded-model-finding" id="bounded-model-finding"><h3>Bounded Model-Finding</h3></a>
<p>Unlike conventional model-finders such as <a href="http://alloytools.org">Alloy</a>, Razor doesn't require the user to provide a
bound on the size of the models that it constructs. However, Razor may never terminate when running on theories with
non-finite models -- it can be shown that a run of Razor on an unsatisfiable theory (i.e., a theory with no models)
is guaranteed to terminate (although it might take a very very long time).This is a direct consequence of
semi-decidability of first-order logic.</p>
<p>To guarantee termination, limit the size of the resulting models by the number of their elements using the <code>--bound</code>
option with a value for the <code>domain</code> parameter:</p>
<pre><code>razor solve -i &lt;input&gt; --bound domain=&lt;number&gt;
</code></pre>
<a class="header" href="print.html#model-finding-scheduler" id="model-finding-scheduler"><h3>Model-Finding Scheduler</h3></a>
<p>Use the <code>--scheduler</code> option to choose how Razor processes search branches. The <code>fifo</code> scheduler (the default scheduler)
schedules new branches last and is a more suitable option for processing theories with few small satisfying models.
The <code>lifo</code> scheduler schedules new branches first, and is more suitable for processing theories with many large models.</p>
<pre><code>razor solve -i &lt;input&gt; --scheduler &lt;fifo/lifo&gt;
</code></pre>
<a class="header" href="print.html#example" id="example"><h1>Example</h1></a>
<p>This section presents sample first-order theories, written in Razor's syntax.
All examples are inspired by the events of Game of Thrones (<em>spoiler alert!!</em>).</p>
<ul>
<li><a href="./example/valar-morghulis.html">Valar Morghulis</a>: demonstrates a run of Razor on a simple example.</li>
<li><a href="./example/golden-head.html">Golden Head</a>: runs Razor over an unsatisfiable theory for which no models exist.</li>
<li><a href="./example/hold-the-door.html">Hold the Door</a>: covers more advanced features of Razor on theories with infinite models.</li>
</ul>
<p>For more examples, see Razor's <a href="https://github.com/salmans/rusty-razor/tree/master/theories/examples">example theories</a>.</p>
<a class="header" href="print.html#valar-morghulis" id="valar-morghulis"><h2>Valar Morghulis</h2></a>
<p>All men must die.
Ser Gregor is a man.</p>
<pre><code>// All men must die:
forall x. (Man(x) implies MustDie(x));

// Ser Gregor is a man:
Man('gregor);
</code></pre>
<p>Run Razor on the previous theory <a href="https://github.com/salmans/rusty-razor/blob/master/theories/examples/valar-morghulis.raz">valar-morghulis.raz</a>:</p>
<pre><code>razor solve -i theories/examples/valar-morghulis.raz
</code></pre>
<p>Razor returns only one model:</p>
<pre><code>Domain: e#0

Elements: 'gregor -&gt; e#0

Facts: Man(e#0), MustDie(e#0)
</code></pre>
<p>The model contains only one element <code>e#0</code> in its domain. This element denotes <code>'gregor</code>, a constant in the theory that
represents Ser Gregor. The model also contains two facts: <code>Man(e#0)</code> is a fact that is derived from the second statement
of the theory (i.e., <code>Man('gregor)</code>). The fact <code>MustDie(e#0)</code> is deduced by Razor according to the first statement of
the theory.</p>
<blockquote>
<p>Notice that the previous model is a &quot;minimal&quot; model for the given theory. The element <code>e#0</code> is required to represent
the constant <code>'gregor</code>; the fact <code>Man(e#0)</code> must be present because the theory says so; and, the fact <code>MustDie(e#0)</code>
must be true because of the first statement. Removing any piece of information makes the given structure a non-model of
the theory.</p>
</blockquote>
<a class="header" href="print.html#golden-head" id="golden-head"><h2>Golden Head</h2></a>
<p>While reading &quot;The Lineages and Histories of the Great Houses of the Seven Kingdoms&quot;, Lord Eddard Stark learns that
throughout the history, all male members of House Baratheon were described as &quot;black of hair&quot; and concludes that King
Robert is not Prince Joffrey's (biological) father. A judgment that eventually put his head on a spike.</p>
<p>The next theory describes Ned's thought process:</p>
<pre><code>// A person &quot;x&quot; cannot be both &quot;black of hair&quot; and &quot;golden head&quot;
~(BlackOfHair(x) &amp; GoldenHead(x));

// Traditionally, a Baratheon child &quot;y&quot; inherited his/her father's (&quot;x&quot;'s) family name
Baratheon(x) &amp; father(y) = x -&gt; Baratheon(y);

// King Robert Baratheon is black of hair
Baratheon('robert) &amp; BlackOfHair('robert);

// King Robert is Joffrey's father
father('joffrey) = 'robert;

// Joffrey has golden hair
GoldenHead('joffrey);

// Ned Stark's discovery (every Baratheon &quot;x&quot; is black of hair)
Baratheon(x) -&gt; BlackOfHair(x);
</code></pre>
<p>We can verify Ned's conclusion by running Razor on this theory
<a href="https://github.com/salmans/rusty-razor/blob/master/theories/examples/golden-lion.raz">golden-lion.raz</a>, asking for a
scenario (i.e., model of the theory) that justifies Joffrey's golden head:</p>
<pre><code>razor solve -i theories/examples/golden-lion.raz
</code></pre>
<p>Razor cannot find a model for the previous theory, meaning the theory is inconsistent. Notice that this theory
is satisfiable (i.e., has a model) in the absence of Ned's discovery (try running Razor after commenting out the last
line).</p>
<a class="header" href="print.html#hold-the-door" id="hold-the-door"><h2>Hold the Door</h2></a>
<p>Wyllis was a young stable boy when he heard a voice from his future: &quot;Hold the Door!&quot; The voice transformed Wyllis to
Hodor (Hold the door, Holdde door, Hoddedor, Hodor, Hodor...!), putting him on a life-long journey, leading him to the
moment that he saves Bran's life. Indeed, because of this defining moment in his future, Wyllis became Hodor in his past.</p>
<a class="header" href="print.html#linear-time" id="linear-time"><h4>Linear Time</h4></a>
<p>The theory below describes Hodor's journey assuming that time progresses linearly
<a href="https://github.com/salmans/rusty-razor/blob/master/theories/examples/hodor-linear.raz">hodor-linear.raz</a></p>
<pre><code>// Wyllis hears &quot;Hold the Door&quot; (at time `t`), then he becomes Hodor in the next
// point of time
HoldTheDoor(t) -&gt; Hodor(next(t));

// Hodor, after turning into Hodor at time &quot;t&quot;, holds the Door at some time &quot;tt&quot;
// in future (&quot;tt &gt; t&quot;)
Hodor(t) -&gt; ? tt . HoldTheDoor(tt) &amp; After(t, tt);

// These are the rules by which time progresses linearly:
// (1) a point of time &quot;t1&quot; that is the next of &quot;t0&quot; (i.e., &quot;next(t0)&quot;) is a point of
// time after &quot;t0&quot; (&quot;t1 &gt; t0&quot;)
next(t0) = t1 -&gt; After(t0, t1);

// (2) if a point of time &quot;t1&quot; is after &quot;t0&quot;, it is either immediately
// after &quot;t0&quot; (i.e., &quot;next(t0)&quot;) or there exists some point of time &quot;t2&quot;
// that is immediately after &quot;t0&quot; and before &quot;t1&quot;.
After(t0, t1) -&gt; next(t0) = t1 | ? t2 . next(t0) = t2 &amp; After(t2, t1);

// And we know at some point of time (namely &quot;'t_hodor&quot;), Wyllis became Hodor
Hodor('t_hodor);
</code></pre>
<p>An unbounded run of Razor on the previous theory will never terminate (feel free to press <code>ctrl + c</code> after a
few seconds):</p>
<pre><code>razor solve -i theories/examples/hodor-linear.raz
</code></pre>
<p>Assuming that time progresses linearly, the circular causality between the two events of &quot;holding the door&quot; and
&quot;becoming Hodor&quot; results in an infinitely large model where time progresses unboundedly. We can restrict the size of
the structures constructed by Razor by bounding the number of their elements. For example, if we restrict the number of
elements to 4, Razor will find 9 <em>incomplete</em> structures, which do <em>not</em> satisfy the theory:</p>
<pre><code>razor solve -i theories/examples/hodor-linear.raz --bound domain=4
</code></pre>
<p>For example, the following structure corresponds to an incomplete model where <code>e#0</code> denotes the starting point <code>t_hodor</code>
and <code>e#1</code>, <code>e#2</code> and <code>e#4</code> are other points in time:</p>
<pre><code>Domain: e#0, e#2, e#4, e#1

Elements: 't_hodor -&gt; e#0, sk#0[e#0] -&gt; e#1, next[e#0], sk#1[e#0, e#1] -&gt; e#2,
next[e#1] -&gt; e#4

Facts: After(e#0, e#1), After(e#2, e#1), Hodor(e#0), Hodor(e#4), HoldTheDoor(e#1)
</code></pre>
<p>Now consider <code>e#1</code> and <code>e#2</code>. The incomplete model shows that <code>e#1</code> is after <code>e#2</code>, but neither <code>e#1</code>
immediately follows <code>e#2</code> (no next point for <code>e#2</code>) nor there exists a point that is after <code>e#2</code> and
before <code>e#1</code>, violating the second rule of linear time progression. In general, it may be possible to extend the
incomplete structure to a model of the theory by adding more information to the model. Any model of this particular
theory, however, is infinitely large.</p>
<a class="header" href="print.html#time-loop" id="time-loop"><h4>Time-Loop</h4></a>
<p>Next, we model time as a &quot;big ball of wibbly wobbly timey wimey stuff!&quot; To make it simple, let's assume that time-loops
can only happen at the moment that Hodor heard a voice from the future, namely <code>'t_hodor</code>, changing our rules of
time progression (<a href="https://github.com/salmans/rusty-razor/blob/master/theories/examples/hodor-time-loop.raz">hodor-time-loop.raz</a>):</p>
<pre><code>HoldTheDoor(t) -&gt; Hodor(next(t));

Hodor(t) -&gt; ? tt . HoldTheDoor(tt) &amp; After(t, tt);

next(t0) = t1 -&gt; After(t0, t1);
After(t0, t1) -&gt; (next(t0) = t1) | ? t2 . next(t0) = t2 &amp; After(t2, t1);

// Hold the door moment only happens at 't_hodor
HoldTheDoor(t) -&gt; t = 't_hodor;

Hodor('t_hodor);
</code></pre>
<p>In presence of time-loops, Razor can explain Hodor's curious journey:</p>
<pre><code>razor solve -i theories/examples/hodor-time-loop.raz
</code></pre>
<p>This time, Razor produces infinitely many (finite) models with time-loops of different size. Use can use the <code>--count</code>
option to limit the number of models and halt the process.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
